// @generated by protoc-gen-es v1.6.0 with parameter "target=js"
// @generated from file core/control_plane/networking/v1/service.proto (package core.control_plane.networking.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import { proto3 } from "@bufbuild/protobuf";

/**
 * @generated from enum core.control_plane.networking.v1.AddRouteResponseCode
 */
export const AddRouteResponseCode = proto3.makeEnum(
  "core.control_plane.networking.v1.AddRouteResponseCode",
  [
    {no: 0, name: "INVALID_ADD_ROUTE_RESPONSE_CODE"},
    {no: 1, name: "OK"},
    {no: 2, name: "ERROR"},
    {no: 3, name: "INVALID_REQUEST"},
  ],
);

/**
 * @generated from enum core.control_plane.networking.v1.DeleteRouteCode
 */
export const DeleteRouteCode = proto3.makeEnum(
  "core.control_plane.networking.v1.DeleteRouteCode",
  [
    {no: 0, name: "INVALID_DELETE_ROUTE_RESPONSE_CODE"},
    {no: 1, name: "DELETE_ROUTE_OK"},
    {no: 2, name: "DELETE_ROUTE_ERROR"},
  ],
);

/**
 * AddRouteRequest - Add a route to the networking configuration
 *
 * @generated from message core.control_plane.networking.v1.AddRouteRequest
 */
export const AddRouteRequest = proto3.makeMessageType(
  "core.control_plane.networking.v1.AddRouteRequest",
  () => [
    { no: 1, name: "route", kind: "message", T: Route },
  ],
);

/**
 * AddRouteResponse - Response to adding a route to the networking configuration. Just because a message
 * was received doesn't mean it was successful. The `code` field is used to determine the success of the
 * route entry.
 *
 * @generated from message core.control_plane.networking.v1.AddRouteResponse
 */
export const AddRouteResponse = proto3.makeMessageType(
  "core.control_plane.networking.v1.AddRouteResponse",
  () => [
    { no: 1, name: "code", kind: "enum", T: proto3.getEnumType(AddRouteResponseCode) },
  ],
);

/**
 * @generated from message core.control_plane.networking.v1.ListRoutesRequest
 */
export const ListRoutesRequest = proto3.makeMessageType(
  "core.control_plane.networking.v1.ListRoutesRequest",
  [],
);

/**
 * @generated from message core.control_plane.networking.v1.ListRoutesResponse
 */
export const ListRoutesResponse = proto3.makeMessageType(
  "core.control_plane.networking.v1.ListRoutesResponse",
  () => [
    { no: 1, name: "routes", kind: "message", T: Route, repeated: true },
  ],
);

/**
 * @generated from message core.control_plane.networking.v1.DeleteRouteRequest
 */
export const DeleteRouteRequest = proto3.makeMessageType(
  "core.control_plane.networking.v1.DeleteRouteRequest",
  () => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
);

/**
 * @generated from message core.control_plane.networking.v1.DeleteRouteResponse
 */
export const DeleteRouteResponse = proto3.makeMessageType(
  "core.control_plane.networking.v1.DeleteRouteResponse",
  () => [
    { no: 1, name: "code", kind: "enum", T: proto3.getEnumType(DeleteRouteCode) },
  ],
);

/**
 * Route - Close match to the `Route` proto in envoy. Anything that can't be inferred by the draft
 * framework needs to be added by the `process` adding the route configuration.
 *
 * The process will register individual routes, while cluster and virtual host configuration will be handled by the framework.
 * current integration is `process` -> `fuse` -> `envoy`
 *
 * @generated from message core.control_plane.networking.v1.Route
 */
export const Route = proto3.makeMessageType(
  "core.control_plane.networking.v1.Route",
  () => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "match", kind: "message", T: RouteMatch },
    { no: 3, name: "endpoint", kind: "message", T: Endpoint },
    { no: 4, name: "enable_http2", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ],
);

/**
 * parameters for the endpoint a route will map to
 *
 * @generated from message core.control_plane.networking.v1.Endpoint
 */
export const Endpoint = proto3.makeMessageType(
  "core.control_plane.networking.v1.Endpoint",
  () => [
    { no: 1, name: "host", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "port", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ],
);

/**
 * parameters for matching a route
 *
 * @generated from message core.control_plane.networking.v1.RouteMatch
 */
export const RouteMatch = proto3.makeMessageType(
  "core.control_plane.networking.v1.RouteMatch",
  () => [
    { no: 1, name: "prefix", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "headers", kind: "message", T: HeaderMatchOptions, opt: true },
    { no: 3, name: "grpc_match_options", kind: "message", T: GrpcMatchOptions, opt: true },
    { no: 4, name: "dynamic_metadata", kind: "message", T: DynamicMetadata, opt: true },
    { no: 5, name: "host", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
);

/**
 * consider using the `key/value` from `blueprint` key/value store
 * TODO -> implement pre 1.0 relase of `fuse`
 *
 * @generated from message core.control_plane.networking.v1.HeaderMatchOptions
 */
export const HeaderMatchOptions = proto3.makeMessageType(
  "core.control_plane.networking.v1.HeaderMatchOptions",
  () => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
);

/**
 * GrpcMatchOptions - Options to simplify the matching of a route for grpc. Most request will be grpc and this configuration
 * should make the integration easier.
 * TODO -> implement pre 1.0 relase of `fuse`
 *
 * @generated from message core.control_plane.networking.v1.GrpcMatchOptions
 */
export const GrpcMatchOptions = proto3.makeMessageType(
  "core.control_plane.networking.v1.GrpcMatchOptions",
  [],
);

/**
 * DynamicMetadata - Specifies a set of dynamic metadata that a route must match. Dynamic metadata can be used in a variety of ways
 * and is a powerful feature of envoy `fuse` will most likely use this feature to add additional information to the route.
 * TODO -> implement pre 2.0 relase of `fuse`
 *
 * @generated from message core.control_plane.networking.v1.DynamicMetadata
 */
export const DynamicMetadata = proto3.makeMessageType(
  "core.control_plane.networking.v1.DynamicMetadata",
  [],
);

