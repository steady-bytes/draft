// @generated by protoc-gen-es v1.6.0 with parameter "target=ts"
// @generated from file core/registry/service_discovery/v1/models.proto (package core.registry.service_discovery.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Timestamp } from "@bufbuild/protobuf";

/**
 * Server currently falls into a category that is consuming requests from the outside world
 * the `Job` is something that is private and not serving any external requests. I could however
 * be pulling messages from a message queue, and or doing some batch processing. I.e. some sort of 
 * training.
 *
 * @generated from enum core.registry.service_discovery.v1.ProcessKind
 */
export enum ProcessKind {
  /**
   * @generated from enum value: INVALID_PROCESS_KIND = 0;
   */
  INVALID_PROCESS_KIND = 0,

  /**
   * @generated from enum value: SERVER_PROCESS = 1;
   */
  SERVER_PROCESS = 1,

  /**
   * @generated from enum value: JOB_PROCESS = 2;
   */
  JOB_PROCESS = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ProcessKind)
proto3.util.setEnumType(ProcessKind, "core.registry.service_discovery.v1.ProcessKind", [
  { no: 0, name: "INVALID_PROCESS_KIND" },
  { no: 1, name: "SERVER_PROCESS" },
  { no: 2, name: "JOB_PROCESS" },
]);

/**
 * @generated from enum core.registry.service_discovery.v1.ProcessRunningState
 */
export enum ProcessRunningState {
  /**
   * @generated from enum value: INVALID_PROCESS_RUNNING_STATE = 0;
   */
  INVALID_PROCESS_RUNNING_STATE = 0,

  /**
   * @generated from enum value: PROCESS_STARTING = 1;
   */
  PROCESS_STARTING = 1,

  /**
   * @generated from enum value: PROCESS_TESTING = 2;
   */
  PROCESS_TESTING = 2,

  /**
   * @generated from enum value: PROCESS_RUNNING = 3;
   */
  PROCESS_RUNNING = 3,

  /**
   * @generated from enum value: PROCESS_DICONNECTED = 4;
   */
  PROCESS_DICONNECTED = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(ProcessRunningState)
proto3.util.setEnumType(ProcessRunningState, "core.registry.service_discovery.v1.ProcessRunningState", [
  { no: 0, name: "INVALID_PROCESS_RUNNING_STATE" },
  { no: 1, name: "PROCESS_STARTING" },
  { no: 2, name: "PROCESS_TESTING" },
  { no: 3, name: "PROCESS_RUNNING" },
  { no: 4, name: "PROCESS_DICONNECTED" },
]);

/**
 * @generated from enum core.registry.service_discovery.v1.ProcessHealthState
 */
export enum ProcessHealthState {
  /**
   * @generated from enum value: INVALID_PROCESS_HEALTH_STATE = 0;
   */
  INVALID_PROCESS_HEALTH_STATE = 0,

  /**
   * @generated from enum value: PROCESS_HEALTHY = 1;
   */
  PROCESS_HEALTHY = 1,

  /**
   * @generated from enum value: PROCESS_UNHEALTHY = 2;
   */
  PROCESS_UNHEALTHY = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ProcessHealthState)
proto3.util.setEnumType(ProcessHealthState, "core.registry.service_discovery.v1.ProcessHealthState", [
  { no: 0, name: "INVALID_PROCESS_HEALTH_STATE" },
  { no: 1, name: "PROCESS_HEALTHY" },
  { no: 2, name: "PROCESS_UNHEALTHY" },
]);

/**
 * Entities
 *
 * @generated from message core.registry.service_discovery.v1.Zone
 */
export class Zone extends Message<Zone> {
  constructor(data?: PartialMessage<Zone>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.registry.service_discovery.v1.Zone";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Zone {
    return new Zone().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Zone {
    return new Zone().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Zone {
    return new Zone().fromJsonString(jsonString, options);
  }

  static equals(a: Zone | PlainMessage<Zone> | undefined, b: Zone | PlainMessage<Zone> | undefined): boolean {
    return proto3.util.equals(Zone, a, b);
  }
}

/**
 * ProcessIdentity - 
 *
 * @generated from message core.registry.service_discovery.v1.ProcessIdentity
 */
export class ProcessIdentity extends Message<ProcessIdentity> {
  /**
   * the process_id is assigned when the join request is successful
   * however it does not mean that the process registered, running
   * and in a stage ready to receive traffic
   *
   * @generated from field: string pid = 1;
   */
  pid = "";

  /**
   * the address the registering process must stream it's health, and status messages to
   *
   * @generated from field: string registry_address = 2;
   */
  registryAddress = "";

  /**
   * authentication credentials that must be added to each request to the registry
   *
   * The `nonce` is not added to this message b/c it's added to the service environment
   * the and the chassis is responsible for reading at startup.
   * `nonce` maybe replaced with `cert`
   *
   * @generated from field: core.registry.service_discovery.v1.Token token = 3;
   */
  token?: Token;

  constructor(data?: PartialMessage<ProcessIdentity>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.registry.service_discovery.v1.ProcessIdentity";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "registry_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "token", kind: "message", T: Token },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProcessIdentity {
    return new ProcessIdentity().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProcessIdentity {
    return new ProcessIdentity().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProcessIdentity {
    return new ProcessIdentity().fromJsonString(jsonString, options);
  }

  static equals(a: ProcessIdentity | PlainMessage<ProcessIdentity> | undefined, b: ProcessIdentity | PlainMessage<ProcessIdentity> | undefined): boolean {
    return proto3.util.equals(ProcessIdentity, a, b);
  }
}

/**
 * configuration the registry is giving to the process to run
 *
 * @generated from message core.registry.service_discovery.v1.StartupConfiguration
 */
export class StartupConfiguration extends Message<StartupConfiguration> {
  /**
   * @generated from field: uint32 assigned_port = 1;
   */
  assignedPort = 0;

  constructor(data?: PartialMessage<StartupConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.registry.service_discovery.v1.StartupConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "assigned_port", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartupConfiguration {
    return new StartupConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartupConfiguration {
    return new StartupConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartupConfiguration {
    return new StartupConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: StartupConfiguration | PlainMessage<StartupConfiguration> | undefined, b: StartupConfiguration | PlainMessage<StartupConfiguration> | undefined): boolean {
    return proto3.util.equals(StartupConfiguration, a, b);
  }
}

/**
 * A process is a running program on a computer.
 *
 * @generated from message core.registry.service_discovery.v1.Process
 */
export class Process extends Message<Process> {
  /**
   * pid - is a uuid to identify each process of the system normally
   * this would follow the normal `id` naming convention. But given 
   * a `pid` in most systems is very specific, that tradition will be
   * carried on.
   *
   * @generated from field: string pid = 1;
   */
  pid = "";

  /**
   * name is not required to be unique between other processes. The `pid`
   * is the specific identifier used to lookup a single process.s
   *
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * @generated from field: string group = 3;
   */
  group = "";

  /**
   * @generated from field: string local = 4;
   */
  local = "";

  /**
   * port?
   *
   * @generated from field: string ip_address = 5;
   */
  ipAddress = "";

  /**
   * @generated from field: core.registry.service_discovery.v1.ProcessKind process_kind = 6;
   */
  processKind = ProcessKind.INVALID_PROCESS_KIND;

  /**
   * @generated from field: repeated core.registry.service_discovery.v1.Metadata metadata = 7;
   */
  metadata: Metadata[] = [];

  /**
   * @generated from field: core.registry.service_discovery.v1.GeoPoint location = 8;
   */
  location?: GeoPoint;

  /**
   * @generated from field: google.protobuf.Timestamp joined_time = 9;
   */
  joinedTime?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp left_time = 10;
   */
  leftTime?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp last_status_time = 11;
   */
  lastStatusTime?: Timestamp;

  /**
   * @generated from field: core.registry.service_discovery.v1.ProcessRunningState running_state = 12;
   */
  runningState = ProcessRunningState.INVALID_PROCESS_RUNNING_STATE;

  /**
   * @generated from field: core.registry.service_discovery.v1.ProcessHealthState health_state = 13;
   */
  healthState = ProcessHealthState.INVALID_PROCESS_HEALTH_STATE;

  /**
   * @generated from field: core.registry.service_discovery.v1.Token token = 14;
   */
  token?: Token;

  constructor(data?: PartialMessage<Process>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.registry.service_discovery.v1.Process";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "group", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "local", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "ip_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "process_kind", kind: "enum", T: proto3.getEnumType(ProcessKind) },
    { no: 7, name: "metadata", kind: "message", T: Metadata, repeated: true },
    { no: 8, name: "location", kind: "message", T: GeoPoint },
    { no: 9, name: "joined_time", kind: "message", T: Timestamp },
    { no: 10, name: "left_time", kind: "message", T: Timestamp },
    { no: 11, name: "last_status_time", kind: "message", T: Timestamp },
    { no: 12, name: "running_state", kind: "enum", T: proto3.getEnumType(ProcessRunningState) },
    { no: 13, name: "health_state", kind: "enum", T: proto3.getEnumType(ProcessHealthState) },
    { no: 14, name: "token", kind: "message", T: Token },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Process {
    return new Process().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Process {
    return new Process().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Process {
    return new Process().fromJsonString(jsonString, options);
  }

  static equals(a: Process | PlainMessage<Process> | undefined, b: Process | PlainMessage<Process> | undefined): boolean {
    return proto3.util.equals(Process, a, b);
  }
}

/**
 * Associated data that can be used to lookup the process
 *
 * @generated from message core.registry.service_discovery.v1.Metadata
 */
export class Metadata extends Message<Metadata> {
  /**
   * @generated from field: string pid = 1;
   */
  pid = "";

  /**
   * @generated from field: string key = 2;
   */
  key = "";

  /**
   * @generated from field: string value = 3;
   */
  value = "";

  constructor(data?: PartialMessage<Metadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.registry.service_discovery.v1.Metadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Metadata {
    return new Metadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Metadata {
    return new Metadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Metadata {
    return new Metadata().fromJsonString(jsonString, options);
  }

  static equals(a: Metadata | PlainMessage<Metadata> | undefined, b: Metadata | PlainMessage<Metadata> | undefined): boolean {
    return proto3.util.equals(Metadata, a, b);
  }
}

/**
 * GeoPoint - Is the location of something using standard lat/lng notion.
 *
 * @generated from message core.registry.service_discovery.v1.GeoPoint
 */
export class GeoPoint extends Message<GeoPoint> {
  /**
   * @generated from field: float lat = 1;
   */
  lat = 0;

  /**
   * @generated from field: float lng = 2;
   */
  lng = 0;

  constructor(data?: PartialMessage<GeoPoint>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.registry.service_discovery.v1.GeoPoint";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "lat", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "lng", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GeoPoint {
    return new GeoPoint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GeoPoint {
    return new GeoPoint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GeoPoint {
    return new GeoPoint().fromJsonString(jsonString, options);
  }

  static equals(a: GeoPoint | PlainMessage<GeoPoint> | undefined, b: GeoPoint | PlainMessage<GeoPoint> | undefined): boolean {
    return proto3.util.equals(GeoPoint, a, b);
  }
}

/**
 * Token that is generated when the `Init` function is called with the correct `nonce`
 *
 * @generated from message core.registry.service_discovery.v1.Token
 */
export class Token extends Message<Token> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: string jwt = 3;
   */
  jwt = "";

  constructor(data?: PartialMessage<Token>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.registry.service_discovery.v1.Token";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "jwt", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Token {
    return new Token().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Token {
    return new Token().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Token {
    return new Token().fromJsonString(jsonString, options);
  }

  static equals(a: Token | PlainMessage<Token> | undefined, b: Token | PlainMessage<Token> | undefined): boolean {
    return proto3.util.equals(Token, a, b);
  }
}

