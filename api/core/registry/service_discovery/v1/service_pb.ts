// @generated by protoc-gen-es v1.6.0 with parameter "target=ts"
// @generated from file core/registry/service_discovery/v1/service.proto (package core.registry.service_discovery.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { GeoPoint, Metadata, Process, ProcessHealthState, ProcessIdentity, ProcessKind, ProcessRunningState, StartupConfiguration } from "./models_pb.js";

/**
 * @generated from enum core.registry.service_discovery.v1.LeadershipStatus
 */
export enum LeadershipStatus {
  /**
   * @generated from enum value: LEADERSHIP_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: LEADERSHIP_STATUS_LEADER = 1;
   */
  LEADER = 1,

  /**
   * @generated from enum value: LEADERSHIP_STATUS_FOLLOWER = 2;
   */
  FOLLOWER = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(LeadershipStatus)
proto3.util.setEnumType(LeadershipStatus, "core.registry.service_discovery.v1.LeadershipStatus", [
  { no: 0, name: "LEADERSHIP_STATUS_UNSPECIFIED" },
  { no: 1, name: "LEADERSHIP_STATUS_LEADER" },
  { no: 2, name: "LEADERSHIP_STATUS_FOLLOWER" },
]);

/**
 * ProcessDetails - Messages that are sent from the `Process` to the registry.
 * These details are basic operating messages
 *
 * @generated from message core.registry.service_discovery.v1.ClientDetails
 */
export class ClientDetails extends Message<ClientDetails> {
  /**
   * @generated from field: string pid = 1;
   */
  pid = "";

  /**
   * Ops details
   *
   * @generated from field: core.registry.service_discovery.v1.ProcessRunningState running_state = 2;
   */
  runningState = ProcessRunningState.INVALID_PROCESS_RUNNING_STATE;

  /**
   * @generated from field: core.registry.service_discovery.v1.ProcessHealthState health_state = 3;
   */
  healthState = ProcessHealthState.INVALID_PROCESS_HEALTH_STATE;

  /**
   * @generated from field: core.registry.service_discovery.v1.ProcessKind process_kind = 4;
   */
  processKind = ProcessKind.INVALID_PROCESS_KIND;

  /**
   * only check the token when a `ProcessDetails` message is received.
   *
   * @generated from field: string token = 5;
   */
  token = "";

  /**
   * @generated from field: core.registry.service_discovery.v1.GeoPoint location = 7;
   */
  location?: GeoPoint;

  /**
   * @generated from field: repeated core.registry.service_discovery.v1.Metadata metadata = 8;
   */
  metadata: Metadata[] = [];

  /**
   * @generated from field: string advertise_address = 9;
   */
  advertiseAddress = "";

  constructor(data?: PartialMessage<ClientDetails>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.registry.service_discovery.v1.ClientDetails";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "running_state", kind: "enum", T: proto3.getEnumType(ProcessRunningState) },
    { no: 3, name: "health_state", kind: "enum", T: proto3.getEnumType(ProcessHealthState) },
    { no: 4, name: "process_kind", kind: "enum", T: proto3.getEnumType(ProcessKind) },
    { no: 5, name: "token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "location", kind: "message", T: GeoPoint },
    { no: 8, name: "metadata", kind: "message", T: Metadata, repeated: true },
    { no: 9, name: "advertise_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientDetails {
    return new ClientDetails().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientDetails {
    return new ClientDetails().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientDetails {
    return new ClientDetails().fromJsonString(jsonString, options);
  }

  static equals(a: ClientDetails | PlainMessage<ClientDetails> | undefined, b: ClientDetails | PlainMessage<ClientDetails> | undefined): boolean {
    return proto3.util.equals(ClientDetails, a, b);
  }
}

/**
 * @generated from message core.registry.service_discovery.v1.ClusterDetails
 */
export class ClusterDetails extends Message<ClusterDetails> {
  /**
   * @generated from field: repeated core.registry.service_discovery.v1.Node nodes = 1;
   */
  nodes: Node[] = [];

  constructor(data?: PartialMessage<ClusterDetails>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.registry.service_discovery.v1.ClusterDetails";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nodes", kind: "message", T: Node, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClusterDetails {
    return new ClusterDetails().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClusterDetails {
    return new ClusterDetails().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClusterDetails {
    return new ClusterDetails().fromJsonString(jsonString, options);
  }

  static equals(a: ClusterDetails | PlainMessage<ClusterDetails> | undefined, b: ClusterDetails | PlainMessage<ClusterDetails> | undefined): boolean {
    return proto3.util.equals(ClusterDetails, a, b);
  }
}

/**
 * @generated from message core.registry.service_discovery.v1.Node
 */
export class Node extends Message<Node> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: string address = 2;
   */
  address = "";

  /**
   * @generated from field: core.registry.service_discovery.v1.LeadershipStatus leadership_status = 3;
   */
  leadershipStatus = LeadershipStatus.UNSPECIFIED;

  constructor(data?: PartialMessage<Node>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.registry.service_discovery.v1.Node";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "leadership_status", kind: "enum", T: proto3.getEnumType(LeadershipStatus) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Node {
    return new Node().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Node {
    return new Node().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Node {
    return new Node().fromJsonString(jsonString, options);
  }

  static equals(a: Node | PlainMessage<Node> | undefined, b: Node | PlainMessage<Node> | undefined): boolean {
    return proto3.util.equals(Node, a, b);
  }
}

/**
 * InitRequest - Begin the service registry registration flow.
 *
 * @generated from message core.registry.service_discovery.v1.InitializeRequest
 */
export class InitializeRequest extends Message<InitializeRequest> {
  /**
   * Name of the process to be registered. This field is not required to be unique with the other processes in the registry
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * A token will not be issued, and a process will not be able to connect to the `SystemJournal` if the `nonce` is not signed with the correct public key
   *
   * @generated from field: string nonce = 2;
   */
  nonce = "";

  constructor(data?: PartialMessage<InitializeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.registry.service_discovery.v1.InitializeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "nonce", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InitializeRequest {
    return new InitializeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InitializeRequest {
    return new InitializeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InitializeRequest {
    return new InitializeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: InitializeRequest | PlainMessage<InitializeRequest> | undefined, b: InitializeRequest | PlainMessage<InitializeRequest> | undefined): boolean {
    return proto3.util.equals(InitializeRequest, a, b);
  }
}

/**
 * InitResponse - Details used by the client to provided to complete the connection
 * If the token is lost and the registry has not received a `ProcessDetails` message within a 2 mintues
 * of the token being forged then the client will have to reinit to connect to the registry/system.
 *
 * @generated from message core.registry.service_discovery.v1.InitializeResponse
 */
export class InitializeResponse extends Message<InitializeResponse> {
  /**
   * If the init request was succesful then an identity will be given to the process so that it
   * can stream it's operational details to the registry
   *
   * @generated from field: core.registry.service_discovery.v1.ProcessIdentity process_identity = 1;
   */
  processIdentity?: ProcessIdentity;

  /**
   * Startup configuration
   *
   * @generated from field: core.registry.service_discovery.v1.StartupConfiguration configuration = 2;
   */
  configuration?: StartupConfiguration;

  constructor(data?: PartialMessage<InitializeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.registry.service_discovery.v1.InitializeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "process_identity", kind: "message", T: ProcessIdentity },
    { no: 2, name: "configuration", kind: "message", T: StartupConfiguration },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InitializeResponse {
    return new InitializeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InitializeResponse {
    return new InitializeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InitializeResponse {
    return new InitializeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: InitializeResponse | PlainMessage<InitializeResponse> | undefined, b: InitializeResponse | PlainMessage<InitializeResponse> | undefined): boolean {
    return proto3.util.equals(InitializeResponse, a, b);
  }
}

/**
 * @generated from message core.registry.service_discovery.v1.QueryRequest
 */
export class QueryRequest extends Message<QueryRequest> {
  /**
   * @generated from field: core.registry.service_discovery.v1.Filter filter = 1;
   */
  filter?: Filter;

  constructor(data?: PartialMessage<QueryRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.registry.service_discovery.v1.QueryRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "filter", kind: "message", T: Filter },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryRequest {
    return new QueryRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryRequest {
    return new QueryRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryRequest {
    return new QueryRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryRequest | PlainMessage<QueryRequest> | undefined, b: QueryRequest | PlainMessage<QueryRequest> | undefined): boolean {
    return proto3.util.equals(QueryRequest, a, b);
  }
}

/**
 * @generated from message core.registry.service_discovery.v1.Filter
 */
export class Filter extends Message<Filter> {
  /**
   * @generated from oneof core.registry.service_discovery.v1.Filter.attribute
   */
  attribute: {
    /**
     * @generated from field: string id = 1;
     */
    value: string;
    case: "id";
  } | {
    /**
     * @generated from field: string group = 2;
     */
    value: string;
    case: "group";
  } | {
    /**
     * @generated from field: string all = 3;
     */
    value: string;
    case: "all";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Filter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.registry.service_discovery.v1.Filter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "attribute" },
    { no: 2, name: "group", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "attribute" },
    { no: 3, name: "all", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "attribute" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Filter {
    return new Filter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Filter {
    return new Filter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Filter {
    return new Filter().fromJsonString(jsonString, options);
  }

  static equals(a: Filter | PlainMessage<Filter> | undefined, b: Filter | PlainMessage<Filter> | undefined): boolean {
    return proto3.util.equals(Filter, a, b);
  }
}

/**
 * @generated from message core.registry.service_discovery.v1.QueryResponse
 */
export class QueryResponse extends Message<QueryResponse> {
  /**
   * @generated from field: map<string, core.registry.service_discovery.v1.Process> data = 1;
   */
  data: { [key: string]: Process } = {};

  constructor(data?: PartialMessage<QueryResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.registry.service_discovery.v1.QueryResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Process} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryResponse {
    return new QueryResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryResponse {
    return new QueryResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryResponse {
    return new QueryResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryResponse | PlainMessage<QueryResponse> | undefined, b: QueryResponse | PlainMessage<QueryResponse> | undefined): boolean {
    return proto3.util.equals(QueryResponse, a, b);
  }
}

/**
 * @generated from message core.registry.service_discovery.v1.FinalizeRequest
 */
export class FinalizeRequest extends Message<FinalizeRequest> {
  /**
   * @generated from field: string pid = 1;
   */
  pid = "";

  constructor(data?: PartialMessage<FinalizeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.registry.service_discovery.v1.FinalizeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FinalizeRequest {
    return new FinalizeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FinalizeRequest {
    return new FinalizeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FinalizeRequest {
    return new FinalizeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: FinalizeRequest | PlainMessage<FinalizeRequest> | undefined, b: FinalizeRequest | PlainMessage<FinalizeRequest> | undefined): boolean {
    return proto3.util.equals(FinalizeRequest, a, b);
  }
}

/**
 * @generated from message core.registry.service_discovery.v1.FinalizeResponse
 */
export class FinalizeResponse extends Message<FinalizeResponse> {
  /**
   * @generated from field: string pid = 1;
   */
  pid = "";

  constructor(data?: PartialMessage<FinalizeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.registry.service_discovery.v1.FinalizeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FinalizeResponse {
    return new FinalizeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FinalizeResponse {
    return new FinalizeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FinalizeResponse {
    return new FinalizeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: FinalizeResponse | PlainMessage<FinalizeResponse> | undefined, b: FinalizeResponse | PlainMessage<FinalizeResponse> | undefined): boolean {
    return proto3.util.equals(FinalizeResponse, a, b);
  }
}

/**
 * @generated from message core.registry.service_discovery.v1.ReportHealthRequest
 */
export class ReportHealthRequest extends Message<ReportHealthRequest> {
  constructor(data?: PartialMessage<ReportHealthRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.registry.service_discovery.v1.ReportHealthRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReportHealthRequest {
    return new ReportHealthRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReportHealthRequest {
    return new ReportHealthRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReportHealthRequest {
    return new ReportHealthRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ReportHealthRequest | PlainMessage<ReportHealthRequest> | undefined, b: ReportHealthRequest | PlainMessage<ReportHealthRequest> | undefined): boolean {
    return proto3.util.equals(ReportHealthRequest, a, b);
  }
}

/**
 * @generated from message core.registry.service_discovery.v1.ReportHealthResponse
 */
export class ReportHealthResponse extends Message<ReportHealthResponse> {
  constructor(data?: PartialMessage<ReportHealthResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.registry.service_discovery.v1.ReportHealthResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReportHealthResponse {
    return new ReportHealthResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReportHealthResponse {
    return new ReportHealthResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReportHealthResponse {
    return new ReportHealthResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ReportHealthResponse | PlainMessage<ReportHealthResponse> | undefined, b: ReportHealthResponse | PlainMessage<ReportHealthResponse> | undefined): boolean {
    return proto3.util.equals(ReportHealthResponse, a, b);
  }
}

